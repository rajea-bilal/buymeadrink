# Clerk & Convex ID System Explained

## Overview

This guide explains the three different ID systems used in BuyMeADrink and when to use each one.

---

## The Three Different IDs 🆔

### **1. Clerk ID** (aka `tokenIdentifier` or `subject`)

**Example:** `user_2d8q1K5X8z0fL9pR`

**What it is:**
- A unique identifier issued by Clerk when a user signs up
- Comes from Clerk's authentication system
- Permanent for that user in Clerk
- Format: String like `user_[random]` or `google_[id]` (depends on auth method)

**Token Identifier:**
- This is the `subject` claim in the JWT token that Clerk issues
- It's what identifies the user to Clerk's servers
- Sent with every authenticated request

**When to use Clerk ID:**
- ✅ Frontend queries (you have `user.id` from `useUser()`)
- ✅ Linking to external auth providers (Stripe, etc.)
- ✅ Direct lookups from Clerk API
- ✅ When you need a permanent cross-system identifier
- ✅ Calling Convex functions from frontend (pass as parameter)

**Example on Frontend:**
```typescript
const { user } = useUser();
const clerkId = user?.id; // "user_2d8q1K5X8z0fL9pR"

// Query creator by Clerk ID
const creator = useQuery(
  api.creators.getCreatorByClerkId, 
  { clerkId: user?.id }
);
```

---

### **2. Convex User ID** (aka `users._id`)

**Example:** `k97ao8p3g98aen0qyzq`

**What it is:**
- A unique document ID generated by Convex when you insert into the `users` table
- Comes from Convex database (auto-generated)
- Exists as long as the document exists
- Format: String like `[random24chars]` (Convex's internal format)
- Type in TypeScript: `Id<"users">`

**When to use Convex User ID:**
- ✅ Foreign key references (like in `creators.userId`)
- ✅ Internal database queries and joins
- ✅ Backend Convex functions
- ✅ When you need to reference a specific user document
- ✅ Never directly expose this to frontend (security)

**Example in Backend:**
```typescript
export const getCreatorByUserId = query({
  args: { userId: v.id("users") }, // Convex user ID
  handler: async (ctx, args) => {
    // Use userId for database queries
    const creator = await ctx.db
      .query("creators")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .first();
  }
});
```

---

### **3. Creator ID** (aka `creators._id`)

**Example:** `k97ao8p3g98aen0qyzq`

**What it is:**
- A unique document ID for creator profiles
- Generated by Convex when a creator signs up
- Type in TypeScript: `Id<"creators">`

**When to use Creator ID:**
- ✅ When fetching creator profiles
- ✅ When creating gifts, tiers, etc. for that creator
- ✅ Anytime you reference a specific creator in queries

---

## The Data Flow 🔄

```
┌─────────────────────────────────────────────────────────────┐
│                    USER SIGNS UP                            │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
        ┌──────────────────────────────┐
        │  Clerk Issues JWT Token      │
        │  with subject: "user_2d8q1K" │ ◄─── CLERK ID
        │  (stored as tokenIdentifier) │
        └──────────────────┬───────────┘
                           │
                           ▼
        ┌──────────────────────────────┐
        │ Convex receives JWT          │
        │ Creates users document:      │
        │ {                            │
        │   _id: "k97ao8p3g98aen0qyzq" │ ◄─── CONVEX USER ID
        │   email: "user@test.com"     │
        │   tokenIdentifier: "user_..." │ ◄─── CLERK ID (stored here)
        │   emailVerified: false       │
        │   createdAt: 123456789       │
        │ }                            │
        └──────────────────┬───────────┘
                           │
                           ▼
        ┌──────────────────────────────┐
        │ User creates creator profile │
        │ Creates creators document:   │
        │ {                            │
        │   _id: "k97ao8p3g98aen0qyzq" │ ◄─── CREATOR ID
        │   userId: "k97ao8p3g98aen..." │ ◄─── CONVEX USER ID (foreign key!)
        │   clerkId: "user_..."        │ ◄─── CLERK ID (stored here too)
        │   handle: "conor"            │
        │   email: "user@test.com"     │
        │   createdAt: 123456789       │
        │   lastUpdated: 123456789     │
        │ }                            │
        └──────────────────────────────┘
```

---

## Where Each ID Should Be Used 📍

### **Frontend (React Components)**

```typescript
import { useUser } from "@clerk/react-router";
import { useQuery } from "convex/react";
import { api } from "convex/_generated/api";

function CreatorDashboard() {
  const { user } = useUser();
  
  // ✅ DO: Use Clerk ID from frontend
  const clerkId = user?.id; // "user_2d8q1K5X8z0fL9pR"
  
  // ✅ DO: Query creator by Clerk ID
  const creator = useQuery(
    api.creators.getCreatorByClerkId, 
    { clerkId: user?.id }
  );

  // ❌ DON'T: Use Convex user._id on frontend
  // You don't have it directly! It's only in the backend.
  
  return (
    <div>
      {creator && <h1>{creator.name}</h1>}
    </div>
  );
}
```

### **Backend Convex Functions**

```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// ✅ Lookup by Clerk ID (from frontend)
export const getCreatorByClerkId = query({
  args: { clerkId: v.string() },
  handler: async (ctx, args) => {
    // 1. Find the user by Clerk ID
    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", args.clerkId))
      .unique();
    
    if (!user) return null;
    
    // 2. Use the Convex user ID to find creator
    const creator = await ctx.db
      .query("creators")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();
    
    return creator;
  }
});

// ✅ Internal: Lookup by Convex user ID
export const getCreatorByUserId = query({
  args: { userId: v.id("users") }, // Convex ID
  handler: async (ctx, args) => {
    // Use Convex ID directly
    const creator = await ctx.db
      .query("creators")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .first();
    
    return creator;
  }
});

// ✅ Creating a user: Store both IDs
export const upsertUser = mutation({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    
    if (!identity) return null;
    
    // Store both Clerk ID and create Convex ID
    const userId = await ctx.db.insert("users", {
      email: identity.email,
      name: identity.name,
      tokenIdentifier: identity.subject, // ✅ Clerk ID (string)
      emailVerified: false,
      createdAt: Date.now(),
    });
    
    return userId; // ✅ Returns Convex user ID (k97ao8p3g98aen0qyzq)
  }
});

// ✅ Creating a creator: Link to Convex user ID
export const createCreator = mutation({
  args: {
    handle: v.string(),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    // Find the user by Clerk ID
    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.subject))
      .unique();
    
    if (!user) throw new Error("User not found");
    
    // Create creator with Convex user ID (not Clerk ID!)
    const creatorId = await ctx.db.insert("creators", {
      userId: user._id, // ✅ Use Convex user ID as foreign key
      clerkId: identity.subject, // ✅ Store Clerk ID for reference
      email: user.email, // ✅ Cache email for efficiency
      handle: args.handle,
      name: args.name,
      createdAt: Date.now(),
      lastUpdated: Date.now(),
    });
    
    return creatorId;
  }
});
```

### **Database Schema**

```typescript
// convex/schema.ts
export default defineSchema({
  users: defineTable({
    email: v.string(),
    name: v.optional(v.string()),
    tokenIdentifier: v.string(), // ✅ Clerk ID (string)
    emailVerified: v.boolean(),
    createdAt: v.number(),
  })
    .index("by_token", ["tokenIdentifier"]) // ✅ Index on Clerk ID
    .index("by_email", ["email"]),
  
  creators: defineTable({
    userId: v.id("users"), // ✅ Convex user ID (foreign key)
    clerkId: v.optional(v.string()), // ✅ Clerk ID (for reference)
    email: v.optional(v.string()), // ✅ Cached from users table
    handle: v.string(),
    name: v.string(),
    createdAt: v.number(),
    lastUpdated: v.number(),
  })
    .index("by_userId", ["userId"]) // ✅ Index on Convex user ID
    .index("by_clerkId", ["clerkId"]) // ✅ Optional index on Clerk ID
    .index("by_email", ["email"]),
});
```

---

## Quick Reference Table 📋

| ID Type | Example | Format | Where Stored | Type | When to Use |
|---------|---------|--------|--------------|------|------------|
| **Clerk ID** | `user_2d8q1K` | String | JWT token, `tokenIdentifier` field | `string` | Frontend queries, external APIs, auth |
| **Convex User ID** | `k97ao8p3g98aen0qyzq` | String | `users._id` field | `v.id("users")` / `Id<"users">` | Database joins, foreign keys, backend |
| **Creator ID** | `k97ao8p3g98aen0qyzq` | String | `creators._id` field | `v.id("creators")` / `Id<"creators">` | Creator profile references |

---

## Common Patterns 🔧

### **Pattern 1: Frontend → Backend Query**

Frontend calls backend with Clerk ID:
```typescript
// Frontend
const creator = useQuery(
  api.creators.getCreatorByClerkId,
  { clerkId: user?.id } // Pass Clerk ID
);

// Backend receives Clerk ID, converts to Convex ID
export const getCreatorByClerkId = query({
  args: { clerkId: v.string() },
  handler: async (ctx, args) => {
    // Convert Clerk ID → Convex user ID → Creator
    const user = await ctx.db.query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", args.clerkId))
      .unique();
    
    if (!user) return null;
    
    return await ctx.db.query("creators")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();
  }
});
```

### **Pattern 2: Authenticated Mutation**

```typescript
export const updateCreatorProfile = mutation({
  args: { name: v.string() },
  handler: async (ctx, args) => {
    // Get Clerk ID from auth context
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");
    
    // Convert to Convex IDs
    const user = await ctx.db.query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.subject))
      .unique();
    
    const creator = await ctx.db.query("creators")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();
    
    // Update with Convex ID
    await ctx.db.patch(creator._id, { name: args.name });
  }
});
```

### **Pattern 3: Internal Backend Query**

When one backend function calls another with Convex IDs:
```typescript
// This function has the Convex user ID
export const getCreatorGifts = query({
  args: { userId: v.id("users") }, // Already have Convex ID
  handler: async (ctx, args) => {
    // Can use Convex ID directly
    const creator = await ctx.db.query("creators")
      .withIndex("by_userId", (q) => q.eq("userId", args.userId))
      .first();
    
    if (!creator) return [];
    
    return await ctx.db.query("gifts")
      .withIndex("by_creator_and_active", (q) =>
        q.eq("creatorId", creator._id).eq("active", true)
      )
      .collect();
  }
});
```

---

## Security Notes 🔒

### **DO:**
- ✅ Store Clerk ID in `tokenIdentifier` field
- ✅ Use Convex IDs for foreign keys
- ✅ Pass Clerk ID from frontend to backend
- ✅ Cache email on creators table for efficiency

### **DON'T:**
- ❌ Expose Convex user `_id` to frontend
- ❌ Use Clerk ID as a database foreign key
- ❌ Pass Convex `_id` in API responses
- ❌ Store Convex IDs in JWT tokens

---

## Troubleshooting 🐛

### **Error: "Argument of type 'string' is not assignable to parameter of type 'Id<"users">'**

**Problem:** You're passing a string where a Convex ID is expected

**Solution:** 
- If on frontend: Pass Clerk ID to a backend function that converts it
- If in backend: Make sure you're using `v.id("users")` not `v.string()`

```typescript
// ❌ Wrong
const creator = await ctx.db.query("creators")
  .withIndex("by_userId", (q) => q.eq("userId", user.id)) // user.id is string!
  .first();

// ✅ Right
const creator = await ctx.db.query("creators")
  .withIndex("by_userId", (q) => q.eq("userId", user._id)) // user._id is Id<"users">
  .first();
```

### **Error: "Calling query with unexpected arguments"**

**Problem:** Passing Convex ID where Clerk ID is expected

**Solution:** Check which query you're calling
```typescript
// ✅ getCreatorByClerkId expects Clerk ID
useQuery(api.creators.getCreatorByClerkId, { clerkId: user?.id })

// ✅ getCreatorByUserId expects Convex user ID (internal use only)
// Don't call this from frontend!
```

---

## Summary

- **Frontend**: Use Clerk IDs (from `useUser().id`)
- **Backend Lookup**: Convert Clerk ID to Convex user ID first
- **Database**: Use Convex IDs for all foreign keys and references
- **Storage**: Keep both for flexibility but use Convex IDs as the source of truth

